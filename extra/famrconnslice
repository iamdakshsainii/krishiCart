/* eslint-disable no-unused-vars */
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
import axios from 'axios';
import { toast } from 'react-toastify';
const API_URL = import.meta.env.VITE_API_URL;

const getAuthConfig = (getState, isMultipart = false) => {
  const token = getState().auth.token;
  return {
    headers: {
      Authorization: `Bearer ${token}`,
      'Content-Type': isMultipart ? 'multipart/form-data' : 'application/json'
    }
  };
};

const handleApiError = (error, customMessage) => {
  const message = customMessage || error.response?.data?.message || error.message || 'An unexpected error occurred';
  toast.error(message);
  return message;
};

const createApiCall = async (apiFunction, retries = 3) => {
  for (let i = 0; i < retries; i++) {
    try {
      return await apiFunction();
    } catch (error) {
      if (i === retries - 1) throw error;
      if (error.response?.status >= 500) {
        await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
        continue;
      }
      throw error;
    }
  }
};

const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

export const createPost = createAsyncThunk(
  'farmConnect/createPost',
  async (formData, { getState, rejectWithValue, dispatch }) => {
    try {
      const tempPost = {
        _id: `temp-${Date.now()}`,
        content: formData.get('content'),
        author: getState().auth.user,
        createdAt: new Date().toISOString(),
        likes: [],
        comments: [],
        isTemporary: true
      };
      dispatch(addOptimisticPost(tempPost));
      const result = await createApiCall(async () => {
        const { data } = await axios.post(
          `${API_URL}/farm-connect/posts`,
          formData,
          getAuthConfig(getState, true)
        );
        return data.data;
      });
      toast.success('Post created successfully! 🌱');
      dispatch(removeOptimisticPost(tempPost._id));
      return result;
    } catch (error) {
      dispatch(removeOptimisticPost(`temp-${Date.now()}`));
      return rejectWithValue(handleApiError(error, 'Failed to create post'));
    }
  }
);

export const createStory = createAsyncThunk(
  'farmConnect/createStory',
  async (formData, { getState, rejectWithValue, dispatch }) => {
    try {
      const tempStory = {
        _id: `temp-story-${Date.now()}`,
        title: formData.get('title'),
        content: formData.get('content'),
        author: getState().auth.user,
        createdAt: new Date().toISOString(),
        isTemporary: true
      };
      dispatch(addOptimisticStory(tempStory));
      const result = await createApiCall(async () => {
        const { data } = await axios.post(
          `${API_URL}/farm-connect/stories`,
          formData,
          getAuthConfig(getState, true)
        );
        return data.data;
      });
      toast.success('Story shared successfully! 📖');
      dispatch(removeOptimisticStory(tempStory._id));
      return result;
    } catch (error) {
      dispatch(removeOptimisticStory(`temp-story-${Date.now()}`));
      return rejectWithValue(handleApiError(error, 'Failed to create story'));
    }
  }
);

export const likePost = createAsyncThunk(
  'farmConnect/likePost',
  async (postId, { getState, rejectWithValue, dispatch }) => {
    try {
      const currentUser = getState().auth.user;
      dispatch(toggleLikeOptimistic({ postId, userId: currentUser._id }));
      const { data } = await axios.post(
        `${API_URL}/farm-connect/posts/${postId}/like`,
        {},
        getAuthConfig(getState)
      );
      return { postId, updatedPost: data.data };
    } catch (error) {
      dispatch(toggleLikeOptimistic({ postId, userId: getState().auth.user._id }));
      return rejectWithValue(handleApiError(error, 'Failed to update like'));
    }
  }
);

export const likeStory = createAsyncThunk(
  'farmConnect/likeStory',
  async (storyId, { getState, rejectWithValue, dispatch }) => {
    try {
      const currentUser = getState().auth.user;
      dispatch(toggleLikeStoryOptimistic({ storyId, userId: currentUser._id }));
      const { data } = await axios.post(
        `${API_URL}/farm-connect/stories/${storyId}/like`,
        {},
        getAuthConfig(getState)
      );
      toast.success('Story like updated! ❤️');
      return { storyId, updatedStory: data.data };
    } catch (error) {
      dispatch(toggleLikeStoryOptimistic({ storyId, userId: getState().auth.user._id }));
      return rejectWithValue(handleApiError(error, 'Failed to update story like'));
    }
  }
);

export const addComment = createAsyncThunk(
  'farmConnect/addComment',
  async ({ postId, content }, { getState, rejectWithValue, dispatch }) => {
    try {
      const tempComment = {
        _id: `temp-comment-${Date.now()}`,
        content,
        author: getState().auth.user,
        createdAt: new Date().toISOString(),
        isTemporary: true
      };
      dispatch(addOptimisticComment({ postId, comment: tempComment }));
      const { data } = await axios.post(
        `${API_URL}/farm-connect/posts/${postId}/comments`,
        { content },
        getAuthConfig(getState)
      );
      dispatch(removeOptimisticComment({ postId, commentId: tempComment._id }));
      toast.success('Comment added! 💬');
      return { postId, newComment: data.data };
    } catch (error) {
      dispatch(removeOptimisticComment({ postId, commentId: `temp-comment-${Date.now()}` }));
      return rejectWithValue(handleApiError(error, 'Failed to add comment'));
    }
  }
);

export const getFarmerProfile = createAsyncThunk(
  'farmConnect/getFarmerProfile',
  async (farmerId, { getState, rejectWithValue }) => {
    try {
      const state = getState().farmConnect;
      const cacheKey = `farmer-${farmerId}`;
      const cachedProfile = state.profileCache[cacheKey];
      if (cachedProfile && Date.now() - cachedProfile.timestamp < CACHE_DURATION) {
        return { profile: cachedProfile.data, fromCache: true };
      }
      const { data } = await axios.get(
        `${API_URL}/farm-connect/farmers/${farmerId}`,
        getAuthConfig(getState)
      );
      return { profile: data.data, cacheKey, fromCache: false };
    } catch (error) {
      return rejectWithValue(handleApiError(error, 'Failed to fetch farmer profile'));
    }
  }
);

export const fetchPosts = createAsyncThunk(
  'farmConnect/fetchPosts',
  async ({ page = 1, limit = 10, refresh = false } = {}, { getState, rejectWithValue }) => {
    try {
      const state = getState().farmConnect;
      if (!refresh && state.posts.length > 0 && !state.shouldRefreshPosts) {
        return { posts: state.posts, fromCache: true };
      }
      const { data } = await axios.get(
        `${API_URL}/farm-connect/posts?page=${page}&limit=${limit}`,
        getAuthConfig(getState)
      );
      return { posts: data.data || [], page, fromCache: false };
    } catch (error) {
      return rejectWithValue(handleApiError(error, 'Failed to fetch posts'));
    }
  }
);

export const fetchStories = createAsyncThunk(
  'farmConnect/fetchStories',
  async ({ page = 1, limit = 10, refresh = false } = {}, { getState, rejectWithValue }) => {
    try {
      const state = getState().farmConnect;
      if (!refresh && state.stories.length > 0 && !state.shouldRefreshStories) {
        return { stories: state.stories, fromCache: true };
      }
      const { data } = await axios.get(
        `${API_URL}/farm-connect/stories?page=${page}&limit=${limit}`,
        getAuthConfig(getState)
      );
      return { stories: data.data || [], page, fromCache: false };
    } catch (error) {
      return rejectWithValue(handleApiError(error, 'Failed to fetch stories'));
    }
  }
);

const initialState = {
  posts: [],
  stories: [],
  currentUser: null,
  farmerProfile: null,
  activeTab: 'posts',
  showCreatePostModal: false,
  showCreateStoryModal: false,
  postsLoading: false,
  storiesLoading: false,
  createLoading: false,
  likeLoading: {},
  commentLoading: {},
  profileLoading: false,
  error: null,
  errors: {},
  profileCache: {},
  lastFetched: {
    posts: null,
    stories: null
  },
  shouldRefreshPosts: false,
  shouldRefreshStories: false,
  pagination: {
    posts: { page: 1, hasMore: true, total: 0 },
    stories: { page: 1, hasMore: true, total: 0 }
  },
  filters: {
    posts: { sortBy: 'createdAt', order: 'desc' },
    stories: { sortBy: 'createdAt', order: 'desc' }
  },
  searchQuery: '',
  isOnline: navigator.onLine,
  retryQueue: []
};

const farmConnectSlice = createSlice({
  name: 'farmConnect',
  initialState,
  reducers: {
    setCurrentUser: (state, action) => {
      state.currentUser = action.payload;
    },
    setActiveTab: (state, action) => {
      state.activeTab = action.payload;
    },
    clearError: (state) => {
      state.error = null;
      state.errors = {};
    },
    clearFarmerProfile: (state) => {
      state.farmerProfile = null;
    },
    setShowCreatePostModal: (state, action) => {
      state.showCreatePostModal = action.payload;
    },
    setShowCreateStoryModal: (state, action) => {
      state.showCreateStoryModal = action.payload;
    },
    addOptimisticPost: (state, action) => {
      state.posts.unshift(action.payload);
    },
    removeOptimisticPost: (state, action) => {
      state.posts = state.posts.filter(post => post._id !== action.payload);
    },
    addOptimisticStory: (state, action) => {
      state.stories.unshift(action.payload);
    },
    removeOptimisticStory: (state, action) => {
      state.stories = state.stories.filter(story => story._id !== action.payload);
    },
    addOptimisticComment: (state, action) => {
      const { postId, comment } = action.payload;
      const post = state.posts.find(p => p._id === postId);
      if (post) {
        post.comments = post.comments || [];
        post.comments.push(comment);
      }
    },
    removeOptimisticComment: (state, action) => {
      const { postId, commentId } = action.payload;
      const post = state.posts.find(p => p._id === postId);
      if (post && post.comments) {
        post.comments = post.comments.filter(c => c._id !== commentId);
      }
    },
    toggleLikeOptimistic: (state, action) => {
      const { postId, userId } = action.payload;
      const post = state.posts.find(p => p._id === postId);
      if (post) {
        post.likes = post.likes || [];
        const likeIndex = post.likes.findIndex(like => like.user === userId);
        if (likeIndex >= 0) {
          post.likes.splice(likeIndex, 1);
        } else {
          post.likes.push({ user: userId, createdAt: new Date().toISOString() });
        }
      }
    },
    toggleLikeStoryOptimistic: (state, action) => {
      const { storyId, userId } = action.payload;
      const story = state.stories.find(s => s._id === storyId);
      if (story) {
        story.likes = story.likes || [];
        const index = story.likes.findIndex(like => (typeof like === 'string' ? like === userId : like.user === userId));
        if (index >= 0) {
          story.likes.splice(index, 1);
        } else {
          story.likes.push({ user: userId, createdAt: new Date().toISOString() });
        }
      }
    },
    invalidatePostsCache: (state) => {
      state.shouldRefreshPosts = true;
    },
    invalidateStoriesCache: (state) => {
      state.shouldRefreshStories = true;
    },
    clearCache: (state) => {
      state.profileCache = {};
      state.shouldRefreshPosts = true;
      state.shouldRefreshStories = true;
    },
    setPostsFilter: (state, action) => {
      state.filters.posts = { ...state.filters.posts, ...action.payload };
    },
    setStoriesFilter: (state, action) => {
      state.filters.stories = { ...state.filters.stories, ...action.payload };
    },
    setSearchQuery: (state, action) => {
      state.searchQuery = action.payload;
    },
    setOnlineStatus: (state, action) => {
      state.isOnline = action.payload;
    },
    addToRetryQueue: (state, action) => {
      state.retryQueue.push(action.payload);
    },
    clearRetryQueue: (state) => {
      state.retryQueue = [];
    },
    updateMultiplePosts: (state, action) => {
      const updates = action.payload;
      updates.forEach(({ postId, updates }) => {
        const postIndex = state.posts.findIndex(p => p._id === postId);
        if (postIndex >= 0) {
          state.posts[postIndex] = { ...state.posts[postIndex], ...updates };
        }
      });
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(createPost.pending, (state) => {
        state.createLoading = true;
        state.error = null;
      })
      .addCase(createPost.fulfilled, (state, action) => {
        state.createLoading = false;
        const tempPostIndex = state.posts.findIndex(p => p.isTemporary);
        if (tempPostIndex >= 0) {
          state.posts[tempPostIndex] = action.payload;
        } else {
          state.posts.unshift(action.payload);
        }
        state.showCreatePostModal = false;
      })
      .addCase(createPost.rejected, (state, action) => {
        state.createLoading = false;
        state.error = action.payload;
      })
      .addCase(createStory.pending, (state) => {
        state.createLoading = true;
        state.error = null;
      })
      .addCase(createStory.fulfilled, (state, action) => {
        state.createLoading = false;
        const tempStoryIndex = state.stories.findIndex(s => s.isTemporary);
        if (tempStoryIndex >= 0) {
          state.stories[tempStoryIndex] = action.payload;
        } else {
          state.stories.unshift(action.payload);
        }
        state.showCreateStoryModal = false;
      })
      .addCase(createStory.rejected, (state, action) => {
        state.createLoading = false;
        state.error = action.payload;
      })
      .addCase(likePost.fulfilled, (state, action) => {
        const { postId, updatedPost } = action.payload;
        const index = state.posts.findIndex(post => post._id === postId);
        if (index !== -1) {
          state.posts[index] = { ...state.posts[index], ...updatedPost };
        }
        state.likeLoading[postId] = false;
      })
      .addCase(likePost.rejected, (state, action) => {
        console.error('Like failed:', action.payload);
      })
      .addCase(likeStory.pending, (state, action) => {
        state.likeLoading[action.meta.arg] = true;
      })
      .addCase(likeStory.fulfilled, (state, action) => {
        const { storyId, updatedStory } = action.payload;
        state.likeLoading[storyId] = false;
        const storyIndex = state.stories.findIndex(s => s._id === storyId);
        if (storyIndex !== -1) {
          state.stories[storyIndex] = { ...state.stories[storyIndex], ...updatedStory };
        }
      })
      .addCase(likeStory.rejected, (state, action) => {
        const storyId = action.meta.arg;
        state.likeLoading[storyId] = false;
      })
      .addCase(addComment.fulfilled, (state, action) => {
        const { postId, newComment } = action.payload;
        const post = state.posts.find(p => p._id === postId);
        if (post) {
          post.comments = post.comments.filter(c => !c.isTemporary);
          post.comments.push(newComment);
        }
      })
      .addCase(addComment.rejected, (state, action) => {
        console.error('Comment failed:', action.payload);
      })
      .addCase(getFarmerProfile.pending, (state) => {
        state.profileLoading = true;
        state.error = null;
      })
      .addCase(getFarmerProfile.fulfilled, (state, action) => {
        state.profileLoading = false;
        const { profile, cacheKey, fromCache } = action.payload;
        state.farmerProfile = profile;
        if (!fromCache && cacheKey) {
          state.profileCache[cacheKey] = {
            data: profile,
            timestamp: Date.now()
          };
        }
      })
      .addCase(getFarmerProfile.rejected, (state, action) => {
        state.profileLoading = false;
        state.error = action.payload;
      })
      .addCase(fetchPosts.pending, (state) => {
        state.postsLoading = true;
        state.error = null;
      })
      .addCase(fetchPosts.fulfilled, (state, action) => {
        state.postsLoading = false;
        const { posts, page, fromCache } = action.payload;
        if (page === 1) {
          state.posts = posts;
        } else {
          state.posts = [...state.posts, ...posts];
        }
        if (!fromCache) {
          state.lastFetched.posts = Date.now();
          state.shouldRefreshPosts = false;
        }
        state.pagination.posts.page = page;
        state.pagination.posts.hasMore = posts.length === 10;
      })
      .addCase(fetchPosts.rejected, (state, action) => {
        state.postsLoading = false;
        state.error = action.payload;
        state.posts = [];
      })
      .addCase(fetchStories.pending, (state) => {
        state.storiesLoading = true;
        state.error = null;
      })
      .addCase(fetchStories.fulfilled, (state, action) => {
        state.storiesLoading = false;
        const { stories, page, fromCache } = action.payload;
        if (page === 1) {
          state.stories = stories;
        } else {
          state.stories = [...state.stories, ...stories];
        }
        if (!fromCache) {
          state.lastFetched.stories = Date.now();
          state.shouldRefreshStories = false;
        }
        state.pagination.stories.page = page;
        state.pagination.stories.hasMore = stories.length === 10;
      })
      .addCase(fetchStories.rejected, (state, action) => {
        state.storiesLoading = false;
        state.error = action.payload;
        state.stories = [];
      });
  }
});

export const {
  setCurrentUser,
  setActiveTab,
  clearError,
  clearFarmerProfile,
  setShowCreatePostModal,
  setShowCreateStoryModal,
  addOptimisticPost,
  removeOptimisticPost,
  addOptimisticStory,
  removeOptimisticStory,
  addOptimisticComment,
  removeOptimisticComment,
  toggleLikeOptimistic,
  toggleLikeStoryOptimistic,
  invalidatePostsCache,
  invalidateStoriesCache,
  clearCache,
  setPostsFilter,
  setStoriesFilter,
  setSearchQuery,
  setOnlineStatus,
  addToRetryQueue,
  clearRetryQueue,
  updateMultiplePosts
} = farmConnectSlice.actions;

export default farmConnectSlice.reducer;
